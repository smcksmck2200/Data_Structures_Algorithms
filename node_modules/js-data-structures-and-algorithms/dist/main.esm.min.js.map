{"version":3,"file":"main.esm.min.js","sources":["../src/algorithms/search/array/binary-search/src/binary-search.js","../src/algorithms/search/array/linear-search/src/linear-search.js","../src/algorithms/search/string/boyer-moore-horspool-search/src/boyer-moore-horspool-search.js","../src/algorithms/search/string/naive-search/src/naive-search.js","../src/data-structures/set/src/set.js","../src/algorithms/set/intersection/src/intersection.js","../src/algorithms/set/set-difference/src/set-difference.js","../src/algorithms/set/union/src/union.js","../src/algorithms/set/symmetric-difference/src/symmetric-difference.js","../src/algorithms/sort/bubble-sort/src/bubble-sort.js","../src/algorithms/sort/counting-sort/src/counting-sort.js","../src/algorithms/sort/insertion-sort/src/insertion-sort.js","../src/algorithms/sort/merge-sort/src/merge-sort.js","../src/algorithms/sort/quick-sort/src/quick-sort.js","../src/algorithms/sort/selection-sort/src/selection-sort.js","../src/data-structures/binary-search-tree/src/node.js","../src/data-structures/binary-search-tree/src/binary-search-tree.js","../src/data-structures/doubly-linked-list/src/node.js","../src/data-structures/doubly-linked-list/src/doubly-linked-list.js","../src/data-structures/linked-list/src/node.js","../src/data-structures/linked-list/src/linked-list.js","../src/data-structures/priority-queue/src/priority-queue.js","../src/data-structures/queue/src/queue.js","../src/data-structures/queue/src/queue-from-doubly-linked-list.js","../src/data-structures/stack/src/stack.js","../src/data-structures/stack/src/stack-from-linked-list.js"],"sourcesContent":["/**\n * Binary Search\n *\n * Starts at the midpoint and continues to cut the array into halves\n * Only can be used for sorted arrays\n *\n * Best case performance: Ω(1) (the element you're looking for is located at the array's midpoint)\n * Average case performance: 0(log n)\n * Worst case performance: O(log n) (the element is located near the beginning or end of the array)\n */\n\nexport const binarySearch = (haystack, needle, showLogs) => {\n  if (\n    !(haystack instanceof Array) ||\n    typeof needle === 'undefined' ||\n    needle === null\n  ) {\n    return -1\n  }\n\n  let searchableHaystack = [...haystack]\n  let i = 1\n  let fullHaystackMidpointIndex = 0\n\n  while (searchableHaystack.length > 0) {\n    const midpointIndex = Math.floor(searchableHaystack.length / 2)\n    fullHaystackMidpointIndex += midpointIndex\n\n    /* istanbul ignore next */\n    showLogs &&\n      console.log(\n        `iteration ${i}: midpoint index: ${fullHaystackMidpointIndex}; array to search: ${searchableHaystack.join(\n          ', '\n        )}; ${needle} === ${searchableHaystack[midpointIndex]} ? ... ${\n          needle === searchableHaystack[midpointIndex]\n        }!`\n      )\n\n    if (searchableHaystack[midpointIndex] === needle) {\n      return fullHaystackMidpointIndex\n    } else if (searchableHaystack[midpointIndex] > needle) {\n      fullHaystackMidpointIndex -= midpointIndex\n      searchableHaystack = searchableHaystack.slice(0, midpointIndex)\n    } else {\n      fullHaystackMidpointIndex += 1\n      searchableHaystack = searchableHaystack.slice(midpointIndex + 1)\n    }\n\n    i++\n  }\n  return -1\n}\n","/**\n * Linear Search\n *\n * Starts at the beginning and iterates through the whole array\n *\n * Best case performance: Ω(1) (the element you're looking for is the first in the array)\n * Average case performance: 0(n)\n * Worst case performance: O(n) (the element you're looking for is the last in the array or not in the array at all)\n */\n\nexport const linearSearch = (haystack, needle, showLogs) => {\n  if (\n    !(haystack instanceof Array) ||\n    typeof needle === 'undefined' ||\n    needle === null\n  ) {\n    return -1\n  }\n\n  for (let i = 0; i < haystack.length; i++) {\n    /* istanbul ignore next */\n    showLogs &&\n      console.log(\n        `iteration ${i + 1}: ${needle} === ${haystack[i]} ? ... ${\n          needle === haystack[i]\n        }!`\n      )\n    if (needle === haystack[i]) {\n      return i\n    }\n  }\n  return -1\n}\n","/**\n * Boyer-Moore-Horspool Search\n *\n * Tries to be more efficient by skipping characters when it can.\n *\n * You go through the haystack from left to right, but you start\n * matching from the end of the string to find (the needle).\n *\n * If the last character of the string in the current selection in the\n * haystack isn’t found anywhere in the needle, you can move where you’re\n * searching forward by the entire length of the needle.\n *\n * If the last character of the string in the current selection in the\n * haystack IS found somewhere in the needle, but it’s not a match with the\n * last character in the needle, then you can move where you’re searching\n * forward by the number of indexes that character is from the end of your\n * needle string.\n *\n * If the last character of the string in the current selection in the\n * haystack matches the last character in the needle string, the you\n * iterate backwards from right of left over the needle string, checking\n * for matches. If they all match, you found it! If you get a mismatch,\n * you move where you’re searching forward again.\n *\n * Performance improves with the length of the search string, because\n * that means you can potentially skip more characters each time a bad\n * match occurs.\n *\n * This algorithm is appropriate as a general purpose string search algorithm.\n *\n * Best case performance: Ω(n/m), where n is the length of the string to search and m is the length of the string to find\n * Average case performance: 0(n)\n * Worst case performance: O(n*m), where n is the length of the string to search and m is the length of the string to find\n */\n\nexport const boyerMooreHorspoolSearch = (haystack, needle, showLogs) => {\n  if (typeof haystack !== 'string' || typeof needle !== 'string') {\n    /* istanbul ignore next */\n    showLogs && console.log('bad input, exiting early')\n    return -1\n  }\n\n  const needleLength = needle.length\n  let haystackRemainingLength = haystack.length\n\n  if (needleLength > haystackRemainingLength) {\n    /* istanbul ignore next */\n    showLogs && console.log('needle is longer than the haystack, exiting early')\n    return -1\n  }\n\n  // first loop through the needle once to\n  // create the mismatch table so you know how much\n  // to offset by for each character on mismatch\n  const lastIndexOfNeedle = needleLength - 1\n  const mismatchTable = {}\n  for (let i = 0; i < needleLength; i++) {\n    mismatchTable[needle[i]] = lastIndexOfNeedle - i\n  }\n\n  let jumpAmount\n  let haystackOffset = 0\n  let currentIndex = 0\n\n  // loop through the haystack from beginning to end\n  while (haystackRemainingLength >= needleLength) {\n    // loop through the needle, starting at the end and moving backward\n    for (\n      currentIndex = lastIndexOfNeedle;\n      haystack[haystackOffset + currentIndex] === needle[currentIndex];\n      currentIndex--\n    ) {\n      // if you've gotten all the way to the front of the needle,\n      // then you've found an exact match. you're done!\n      if (currentIndex === 0) {\n        return haystackOffset\n      }\n    }\n\n    // if you're here, that means we got a mismatch and can jump further down the haystack\n    jumpAmount =\n      mismatchTable[haystack[haystackOffset + lastIndexOfNeedle]] ||\n      needleLength\n    haystackRemainingLength -= jumpAmount\n    haystackOffset += jumpAmount\n  }\n\n  // needle was not found in the haystack\n  return -1\n}\n","/**\n * Naive Search\n *\n * Starts at the beginning and iterates through the whole string\n *\n * Best case performance: Ω(1) (the substring you're looking for is the start of the string)\n * Average case performance: 0(n+m)\n * Worst case performance: O(n*m), where the length of the pattern is m and the length of the search string is n\n *     (the substring you're looking for is the end of the string or not in the string at all)\n */\n\nexport const naiveSearch = (haystack, needle, showLogs) => {\n  if (typeof haystack !== 'string' || typeof needle !== 'string') {\n    /* istanbul ignore next */\n    showLogs && console.log('bad input, exiting early')\n    return -1\n  }\n\n  if (needle.length > haystack.length) {\n    /* istanbul ignore next */\n    showLogs && console.log('needle is longer than the haystack, exiting early')\n    return -1\n  }\n\n  for (let i = 0; i < haystack.length; i++) {\n    for (let j = 0; j < needle.length; j++) {\n      if (haystack[i + j] !== needle[j]) {\n        break\n      }\n\n      if (j === needle.length - 1) {\n        return i\n      }\n    }\n  }\n\n  return -1\n}\n","/**\n * Set - A collection of unique items (no duplicates allowed)\n *\n * Methods and properties:\n *\n * - add: Constant — O(1)\n * - remove: Linear — O(n)\n * - has: Linear — O(n)\n * - isEmpty: Constant — O(1)\n * - size: Constant — O(1)\n * - enumerate: Linear - O(n)\n * - clear: Constant - O(1)\n */\n\nexport class Set {\n  constructor() {\n    this.items = []\n    this.length = 0\n  }\n\n  add(val) {\n    if (this.items.indexOf(val) === -1) {\n      this.items.push(val)\n      this.length++\n    }\n    return val\n  }\n\n  remove(val) {\n    const index = this.items.indexOf(val)\n    if (index !== -1) {\n      this.items.splice(index, 1)\n      this.length--\n    }\n    return val\n  }\n\n  has(val) {\n    return this.items.indexOf(val) !== -1\n  }\n\n  isEmpty() {\n    return this.length === 0\n  }\n\n  size() {\n    return this.length\n  }\n\n  enumerate() {\n    return this.items\n  }\n\n  clear() {\n    this.length = 0\n    this.items = []\n    return this.items\n  }\n}\n","/**\n * Intersection\n *\n * Compares two sets and produces a third set that contains all of the\n * intersecting/matching values that are found in both sets\n *\n * Ex. Intersection of { 1, 2, 3 } and { 2, 3, 4 } is { 2, 3 }\n *\n * Performance: Quadratic - O(n * m), where n is the length of set 1 and m is the length of set 2\n * Note: this is sort of like O(n^2) performance\n */\n\nimport { Set } from '../../../../data-structures/set/src/set'\n\nexport const intersection = (set1, set2) => {\n  const intersectionSet = new Set()\n\n  set1.enumerate().forEach(val => {\n    if (set2.has(val)) {\n      intersectionSet.add(val)\n    }\n  })\n\n  set2.enumerate().forEach(val => {\n    if (set1.has(val)) {\n      intersectionSet.add(val)\n    }\n  })\n\n  return intersectionSet\n}\n","/**\n * Set Difference\n *\n * Compares two sets and returns all items of the first set that are not members of the second set\n *\n * Ex. Set difference of { 2, 3, 4 } and { 3, 4, 5 } is { 2 }\n *\n * Performance: Quadratic - O(n * m), where n is the length of set 1 and m is the length of set 2\n * Note: this is sort of like O(n^2) performance\n */\n\nimport { Set } from '../../../../data-structures/set/src/set'\n\nexport const setDifference = (set1, set2) => {\n  const setDifferenceSet = new Set()\n\n  set1.enumerate().forEach(val => {\n    if (!set2.has(val)) {\n      setDifferenceSet.add(val)\n    }\n  })\n\n  return setDifferenceSet\n}\n","/**\n * Union\n *\n * Compares two sets and produces a third set that contains all unique values found in either set\n *\n * Ex. Union of { 1, 2, 3 } and { 3, 4, 5 } is { 1, 2, 3, 4, 5 }\n *\n * Performance: Linear - O(n + m), where n is the length of set 1 and m is the length of set 2\n */\n\nimport { Set } from '../../../../data-structures/set/src/set'\n\nexport const union = (set1, set2) => {\n  const unionSet = new Set()\n  set1.enumerate().forEach(val => unionSet.add(val))\n  set2.enumerate().forEach(val => unionSet.add(val))\n  return unionSet\n}\n","/**\n * Symmetric Difference\n *\n * Compares two sets and returns all of the items that exist in only one of the two sets\n * The symmetric difference is the set difference of the union and intersection of the input sets\n *\n * Ex. Symmetric difference of { 2, 3, 4 } and { 3, 4, 5 } is { 2, 5 }\n *\n * Performance: Quadratic - O(n * m), where n is the length of set 1 and m is the length of set 2\n * Note: this is sort of like O(n^2) performance\n */\n\nimport { setDifference } from '../../set-difference/src/set-difference'\nimport { intersection } from '../../intersection/src/intersection'\nimport { union } from '../../union/src/union'\n\nexport const symmetricDifference = (set1, set2) => {\n  const intersectionSet = intersection(set1, set2)\n  const unionSet = union(set1, set2)\n  return setDifference(unionSet, intersectionSet)\n}\n","/**\n * Bubble Sort\n *\n * Compares each pair of adjacent items and swaps them if they are in the wrong order\n * Continues looping through the array until no more swaps are needed\n * Not appropriate for large unsorted data sets\n *\n * Best case performance: Ω(n) (only one element is out of place, so only one iteration through the array)\n * Average case performance: θ(n^2) (array is mostly unsorted, have to do a loop nested within a loop)\n * Worst case performance: O(n^2) (array is entirely unsorted, have to do a loop nested within a loop)\n *\n * Space required: O(n) (because it operates directly on the input array)\n */\n\nexport const bubbleSort = (arr, showLogs) => {\n  const sortedArr = [...arr]\n  let didSwapSomething = false\n  let iteration = 0\n\n  /* istanbul ignore next */\n  showLogs && console.log(`starting array: ${sortedArr.join(' ')}`)\n\n  do {\n    didSwapSomething = false\n    iteration++\n    for (let i = 0; i < sortedArr.length - 1; i++) {\n      if (sortedArr[i] > sortedArr[i + 1]) {\n        const firstPosition = sortedArr[i]\n        sortedArr[i] = sortedArr[i + 1]\n        sortedArr[i + 1] = firstPosition\n        didSwapSomething = true\n      }\n    }\n\n    /* istanbul ignore next */\n    showLogs &&\n      console.log(`iteration ${iteration}: array: ${sortedArr.join(' ')}`)\n  } while (didSwapSomething)\n\n  return sortedArr\n}\n","/**\n * Counting Sort\n *\n * Counts the occurrence of each element in the input array and uses that to create a sorted output array\n *\n * Best case performance: Ω(n + k) (always loops through the input array, count array, and output array)\n * Average case performance: θ(n + k) (always loops through the input array, count array, and output array)\n * Worst case performance: O(n + k) (always loops through the input array, count array, and output array)\n *\n * Space required: O(n + k)\n */\n\nexport const countingSort = (arr, minValue, maxValue, showLogs) => {\n  const sortedArr = []\n  const countArr = []\n  let min = minValue\n  let max = maxValue\n\n  /* istanbul ignore next */\n  showLogs && console.log(`starting array: ${arr.join(' ')}`)\n\n  if (typeof min === 'undefined' || typeof max === 'undefined') {\n    /* istanbul ignore next */\n    showLogs && console.log('getting min and max values of the input array')\n\n    for (let i = 0; i < arr.length; i++) {\n      const currentElement = arr[i]\n\n      if (i === 0) {\n        min = currentElement\n        max = currentElement\n      }\n\n      if (currentElement < min) {\n        min = currentElement\n      }\n\n      if (currentElement > max) {\n        max = currentElement\n      }\n    }\n  }\n\n  /* istanbul ignore next */\n  showLogs && console.log(`min value: ${min}; max value: ${max}`)\n\n  const countRange = max - min + 1\n  for (let i = 0; i < countRange; i++) {\n    countArr.push(0)\n  }\n\n  /* istanbul ignore next */\n  showLogs && console.log(`initialized count array: ${countArr.join(' ')}`)\n\n  for (let i = 0; i < arr.length; i++) {\n    const currentElement = arr[i]\n    countArr[currentElement - min]++\n  }\n\n  /* istanbul ignore next */\n  showLogs && console.log(`populated count array: ${countArr.join(' ')}`)\n\n  for (let i = 0; i < countArr.length; i++) {\n    while (countArr[i] > 0) {\n      sortedArr.push(i + min)\n      countArr[i]--\n    }\n  }\n\n  /* istanbul ignore next */\n  showLogs && console.log(`sorted output array: ${sortedArr.join(' ')}`)\n\n  return sortedArr\n}\n","/**\n * Insertion Sort\n *\n * Inserts each element into its correct place in the array, one element at a time\n * Loops through the array for every element\n *\n * Everything to the left of the current item is known to be sorted\n * Everything to the right of the current item is unsorted\n * Not appropriate for large unsorted data sets\n *\n * Best case performance: Ω(n) (only one element is out of place, so only one iteration through the array)\n * Average case performance: 0(n^2) (array is mostly unsorted, have to do a loop nested within a loop)\n * Worst case performance: O(n^2) (array is entirely unsorted, have to do a loop nested within a loop)\n *\n * Space required: O(n) (because it operates directly on the input array)\n */\n\nexport const insertionSort = (arr, showLogs) => {\n  let sortedArr = [...arr]\n\n  /* istanbul ignore next */\n  showLogs && console.log(`starting array: ${sortedArr.join(' ')}`)\n\n  for (let i = 1; i < sortedArr.length; i++) {\n    const valueToInsert = sortedArr.splice(i, 1)[0]\n    let didInsertValue = false\n    for (let j = i; j >= 1; j--) {\n      /* istanbul ignore next */\n      showLogs &&\n        console.log(`  comparing ${valueToInsert} with ${sortedArr[j - 1]}`)\n\n      if (valueToInsert > sortedArr[j - 1]) {\n        /* istanbul ignore next */\n        showLogs &&\n          console.log(\n            `    inserting ${valueToInsert} after ${sortedArr[j - 1]}`\n          )\n        sortedArr = [\n          ...sortedArr.slice(0, j),\n          valueToInsert,\n          ...sortedArr.slice(j),\n        ]\n        didInsertValue = true\n        break\n      }\n    }\n    if (!didInsertValue) {\n      /* istanbul ignore next */\n      showLogs && console.log(`    inserting ${valueToInsert} at first index`)\n      sortedArr = [valueToInsert, ...sortedArr]\n    }\n\n    /* istanbul ignore next */\n    showLogs && console.log(`iteration ${i + 1}: array: ${sortedArr.join(' ')}`)\n  }\n\n  return sortedArr\n}\n","/**\n * Merge Sort\n *\n * The array is recursively split in half\n * When the array is in groups of 1, it is reconstructed in sort order\n * Each reconstructed array is merged with the other half\n *\n * So if you had an array of 8 items, it’s broken down into two groups of 4,\n * then four groups of 2, then eight groups of 1\n * Then it’s built back up where you combine the eight groups of 1 into four groups of 2,\n * but you sort within each group of 2. Then you combine the four groups of 2 into two\n * groups of 4, and sort those groups of 4. Then you combine the two groups of 4 into\n * one group of 8, and you sort that group.\n *\n * Appropriate for large data sets\n * Data splitting means that the algorithm can be done in parallel\n *\n * Best case performance: Ω(n log n)\n * Average case performance: 0(n log n)\n * Worst case performance: O(n log n)\n *\n * Space required: O(n) (merge sort can be performed in-place, but it’s often not)\n *\n * Merge sort is a predictable algorithm since the time complexity is the same for the worst, average, and best case\n * If you don’t do it in-place, then you take up extra memory allocations for the temporary arrays\n */\n\nexport const mergeSort = (arr, showLogs) => {\n  /* istanbul ignore next */\n  showLogs && console.log(`current array: ${arr.join(' ')}`)\n\n  if (arr.length < 2) {\n    /* istanbul ignore next */\n    showLogs &&\n      console.log('  array only has 0 or 1 items, so nothing to sort!')\n    return arr\n  }\n\n  // Divide the array into two sub-arrays, right down the middle\n  /* istanbul ignore next */\n  showLogs && console.log('  splitting the array down the middle!')\n  const midpointIndex = Math.floor(arr.length / 2)\n  const leftSubArray = mergeSort(arr.slice(0, midpointIndex), showLogs)\n  const rightSubArray = mergeSort(arr.slice(midpointIndex), showLogs)\n\n  return merge(leftSubArray, rightSubArray, showLogs)\n}\n\nconst merge = (arr1, arr2, showLogs) => {\n  /* istanbul ignore next */\n  showLogs &&\n    console.log(`merging arrays [${arr1.join(' ')}] and [${arr2.join(' ')}]`)\n  const result = []\n  while (arr1.length > 0 && arr2.length > 0) {\n    // The two sub-arrays are always sorted, so in order to combine the two sub-arrays,\n    // we need to pick off the first value from whichever array currently has\n    // a lower value as its first element\n    result.push(arr1[0] < arr2[0] ? arr1.shift() : arr2.shift())\n    /* istanbul ignore next */\n    showLogs &&\n      console.log(\n        `  current merge result from the two sub-arrays: ${result.join(' ')}`\n      )\n  }\n\n  // The while loop stops once one sub-array no longer has any elements,\n  // so this combines the result array with whichever sub-array still\n  // has elements in it\n  const finalResult = result.concat(arr1.length ? arr1 : arr2)\n  /* istanbul ignore next */\n  showLogs &&\n    console.log(\n      `  final merge result from the two sub-arrays: ${finalResult.join(' ')}`\n    )\n\n  return finalResult\n}\n","/**\n * Quick Sort\n *\n * Pick a pivot value and partition the array\n * Put all values smaller than the pivot to the left and all values larger\n * than the pivot to the right\n * Then continue to perform the pivot and partition algorithm on the left\n * and right partitions, and repeat until it’s all sorted\n *\n * Not appropriate for large inverse-sorted data sets\n * You are doing recursion, so be aware that it puts a new function call\n * on the stack the deeper you go\n *\n * Best case performance: Ω(n log n)\n * Average case performance: 0(n log n)\n * Worst case performance: O(n^2)\n *\n * Space required: O(n) (because it operates directly on the input array)\n */\n\nexport const quickSort = (arr, left = 0, right = arr.length - 1, showLogs) => {\n  /* istanbul ignore next */\n  showLogs && console.log(`current array: ${arr.join(' ')}`)\n\n  if (arr.length < 2) {\n    /* istanbul ignore next */\n    showLogs &&\n      console.log('  array only has 0 or 1 items, so nothing to sort!')\n    return arr\n  }\n\n  const pivotIndex = partition(arr, left, right, showLogs) // index returned from partition\n\n  if (left < pivotIndex - 1) {\n    // more elements on the left side of the pivot\n    quickSort(arr, left, pivotIndex - 1, showLogs)\n  }\n\n  if (pivotIndex < right) {\n    // more elements on the right side of the pivot\n    quickSort(arr, pivotIndex, right, showLogs)\n  }\n\n  return arr\n}\n\n// swaps the position of two elements in an array\nconst swap = (arr, leftIndex, rightIndex, showLogs) => {\n  /* istanbul ignore next */\n  showLogs &&\n    console.log(\n      `    swapping elements with values ${arr[leftIndex]} and ${arr[rightIndex]}`\n    )\n\n  const temp = arr[leftIndex]\n  arr[leftIndex] = arr[rightIndex]\n  arr[rightIndex] = temp\n}\n\nconst partition = (arr, leftIndex, rightIndex, showLogs) => {\n  const pivotIndex = Math.floor((rightIndex + leftIndex) / 2)\n  const pivotElement = arr[pivotIndex]\n\n  /* istanbul ignore next */\n  showLogs && console.log(`  pivot element chosen is ${pivotElement}`)\n\n  let currentLeftIndex = leftIndex\n  let currentRightIndex = rightIndex\n\n  /* istanbul ignore next */\n  showLogs &&\n    console.log(\n      `  current left element: ${arr[currentLeftIndex]}, current right element: ${arr[currentRightIndex]}`\n    )\n\n  while (currentLeftIndex <= currentRightIndex) {\n    while (arr[currentLeftIndex] < pivotElement) {\n      /* istanbul ignore next */\n      showLogs &&\n        console.log(\n          `    left element ${\n            arr[currentLeftIndex]\n          } is less than ${pivotElement}, moving right by one element to ${\n            arr[currentLeftIndex + 1]\n          }`\n        )\n\n      currentLeftIndex++\n    }\n\n    /* istanbul ignore next */\n    showLogs &&\n      console.log(\n        `    left element ${arr[currentLeftIndex]} is greater than or equal to ${pivotElement}, so ${arr[currentLeftIndex]} is eligible to be swapped`\n      )\n\n    while (arr[currentRightIndex] > pivotElement) {\n      /* istanbul ignore next */\n      showLogs &&\n        console.log(\n          `    right element ${\n            arr[currentRightIndex]\n          } is greater than ${pivotElement}, moving left by one element to ${\n            arr[currentRightIndex - 1]\n          }`\n        )\n\n      currentRightIndex--\n    }\n\n    /* istanbul ignore next */\n    showLogs &&\n      console.log(\n        `    right element ${arr[currentRightIndex]} is less than or equal to ${pivotElement}, so ${arr[currentRightIndex]} is eligible to be swapped`\n      )\n\n    if (currentLeftIndex <= currentRightIndex) {\n      /* istanbul ignore next */\n      showLogs &&\n        console.log(\n          `    left element ${arr[currentLeftIndex]} is less than or equal to right element ${arr[currentRightIndex]}, so we can swap these two elements`\n        )\n\n      swap(arr, currentLeftIndex, currentRightIndex, showLogs)\n      currentLeftIndex++\n      currentRightIndex--\n\n      /* istanbul ignore next */\n      showLogs && console.log(`    resulting array: ${arr.join(' ')}`)\n    } else {\n      /* istanbul ignore next */\n      showLogs &&\n        console.log(\n          `    left element ${arr[currentLeftIndex]} is NOT less than or equal to right element ${arr[currentRightIndex]}, so we will NOT swap these two elements`\n        )\n    }\n  }\n\n  return currentLeftIndex\n}\n","/**\n * Selection Sort\n *\n * Finds the lowest value in the remaining unsorted items in the array\n * and swaps it into the earliest unsorted position\n * Loops through the array for every element\n *\n * The bubble sort iterates through the entire array for each pass,\n * but the selection sort only has to iterate through the remaining unsorted\n * items for each pass, making it a little more efficient\n * Not appropriate for large unsorted data sets\n *\n * Best case performance: Ω(n^2) (always loops through the entire array)\n * Average case performance: 0(n^2) (always loops through the entire array)\n * Worst case performance: O(n^2) (always loops through the entire array)\n *\n * Space required: O(n) (because it operates directly on the input array)\n */\n\nexport const selectionSort = (arr, showLogs) => {\n  const sortedArr = [...arr]\n\n  /* istanbul ignore next */\n  showLogs && console.log(`starting array: ${sortedArr.join(' ')}`)\n\n  for (let i = 0; i < sortedArr.length - 1; i++) {\n    let minValueIndex = i\n\n    for (let j = i; j < sortedArr.length; j++) {\n      if (sortedArr[j] < sortedArr[minValueIndex]) {\n        minValueIndex = j\n      }\n    }\n\n    const originalStartingValue = sortedArr[i]\n    sortedArr[i] = sortedArr[minValueIndex]\n    sortedArr[minValueIndex] = originalStartingValue\n\n    /* istanbul ignore next */\n    showLogs && console.log(`iteration ${i + 1}: array: ${sortedArr.join(' ')}`)\n  }\n\n  return sortedArr\n}\n","/**\n * Node - Contains a value and a pointer to the left node and to the right node\n *\n * Meant to be used with a binary search tree\n *\n * Methods and properties:\n *\n * - val: any value\n * - left: pointer to the left node (or null)\n * - right: pointer to the right node (or null)\n */\nexport class Node {\n  constructor(val) {\n    this.val = val\n    this.left = null\n    this.right = null\n  }\n}\n","/**\n * Binary Search Tree - a tree in which every node can have at most two children,\n * with lower values on the left and higher values on the right\n *\n * Methods and properties:\n *\n * - insert: average case: Logarithmic - O(log n); worst case: Linear — O(n)\n * - contains: average case: Logarithmic - O(log n); worst case: Linear — O(n)\n * - remove: average case: Logarithmic - O(log n); worst case: Linear — O(n)\n * - isEmpty: Constant — O(1)\n * - inOrderTraversal: average case: Logarithmic - O(log n); worst case: Linear — O(n)\n * - preOrderTraversal: average case: Logarithmic - O(log n); worst case: Linear — O(n)\n * - postOrderTraversal: average case: Logarithmic - O(log n); worst case: Linear — O(n)\n * - clear: Constant - O(1)\n */\n\nimport { Node } from './node'\n\nexport class BinarySearchTree {\n  constructor() {\n    this.root = null\n  }\n\n  insert(val) {\n    const newNode = new Node(val)\n\n    // handle adding the first node\n    if (this.root === null) {\n      this.root = newNode\n      return this.root\n    }\n\n    // adding a node to an existing tree\n    this._insertNode(this.root, newNode)\n\n    return newNode\n  }\n\n  // helper method for recursively finding the correct place to insert the new node\n  _insertNode(currentNode, newNode) {\n    if (currentNode.val > newNode.val && currentNode.left === null) {\n      currentNode.left = newNode\n      return newNode\n    } else if (currentNode.val > newNode.val) {\n      return this._insertNode(currentNode.left, newNode)\n    } else if (\n      (currentNode.val < newNode.val || currentNode.val === newNode.val) &&\n      currentNode.right === null\n    ) {\n      currentNode.right = newNode\n      return newNode\n    } else {\n      return this._insertNode(currentNode.right, newNode)\n    }\n  }\n\n  contains(val) {\n    let doesTreeContainValue = false\n\n    if (this.root === null) {\n      return doesTreeContainValue\n    }\n\n    function findValueInTree(currentNode) {\n      if (currentNode.val === val) {\n        doesTreeContainValue = true\n      } else if (currentNode.left !== null && val < currentNode.val) {\n        findValueInTree(currentNode.left)\n      } else if (currentNode.right !== null && val > currentNode.val) {\n        findValueInTree(currentNode.right)\n      }\n    }\n\n    findValueInTree(this.root)\n\n    return doesTreeContainValue\n  }\n\n  remove(val) {\n    // the root is re-initialized with the root of a modified tree\n    this.root = this._removeNode(this.root, val)\n    return this.root\n  }\n\n  _removeNode(currentNode, key) {\n    // if the root is null then tree is empty\n    if (currentNode === null) {\n      return null\n    }\n\n    // if the value to be deleted is less than the root's value, then move to the left subtree\n    if (key < currentNode.val) {\n      currentNode.left = this._removeNode(currentNode.left, key)\n      return currentNode\n    }\n\n    // if the value to be deleted is greater than the root's value, then move to the right subtree\n    if (key > currentNode.val) {\n      currentNode.right = this._removeNode(currentNode.right, key)\n      return currentNode\n    }\n\n    // if the value to be deleted is equal to the root's data, then delete this node.\n    // the node could have 0, 1, or 2 children\n\n    // deleting a node with no children\n    if (currentNode.left === null && currentNode.right === null) {\n      currentNode = null\n      return currentNode\n    }\n\n    // deleting a node with one child (right)\n    if (currentNode.left === null) {\n      currentNode = currentNode.right\n      return currentNode\n    }\n\n    // deleting a node with one child (left)\n    if (currentNode.right === null) {\n      currentNode = currentNode.left\n      return currentNode\n    }\n\n    // deleting a node with two children.\n    // the minimum node of the right subtree is stored in a temporary variable\n    const temp = this._findMinNode(currentNode.right)\n    currentNode.val = temp.val\n\n    currentNode.right = this._removeNode(currentNode.right, temp.val)\n    return currentNode\n  }\n\n  // 1. Traverse the left subtree (i.e. perform inOrderTraversal on the left subtree)\n  // 2. Visit the root\n  // 3. Traverse the right subtree (i.e. perform inOrderTraversal on the right subtree)\n  inOrderTraversal(node = this.root, callback) {\n    if (node !== null) {\n      this.inOrderTraversal(node.left, callback)\n      if (typeof callback === 'function') {\n        callback(node)\n      }\n      this.inOrderTraversal(node.right, callback)\n    }\n  }\n\n  // 1. Visit the root\n  // 2. Traverse the left subtree (i.e. perform preOrderTraversal on the left subtree)\n  // 3. Traverse the right subtree (i.e. perform preOrderTraversal on the right subtree)\n  preOrderTraversal(node = this.root, callback) {\n    if (node !== null) {\n      if (typeof callback === 'function') {\n        callback(node)\n      }\n      this.preOrderTraversal(node.left, callback)\n      this.preOrderTraversal(node.right, callback)\n    }\n  }\n\n  // 1. Traverse the left subtree (i.e. perform postOrderTraversal on the left subtree)\n  // 2. Traverse the right subtree (i.e. perform postOrderTraversal on the right subtree)\n  // 3. Visit the root\n  postOrderTraversal(node = this.root, callback) {\n    if (node !== null) {\n      this.postOrderTraversal(node.left, callback)\n      this.postOrderTraversal(node.right, callback)\n      if (typeof callback === 'function') {\n        callback(node)\n      }\n    }\n  }\n\n  isEmpty() {\n    return this.root === null\n  }\n\n  clear() {\n    this.root = null\n    return this.root\n  }\n\n  // helper method to find the minimum node in the tree, starting at a specified node\n  _findMinNode(node) {\n    // if the left of a node is null, then it must be the minimum node\n    if (node.left === null) {\n      return node\n    }\n    return this._findMinNode(node.left)\n  }\n}\n","/**\n * Node - Contains a value and a pointer to the next node and to the previous node\n *\n * Meant to be used with a doubly linked list\n *\n * Methods and properties:\n *\n * - val: any value\n * - next: pointer to the next node (or null)\n * - prev: pointer to the previous node (or null)\n */\nexport class Node {\n  constructor(val, next = null, prev = null) {\n    this.val = val\n    this.next = next\n    this.prev = prev\n  }\n}\n","/**\n * Doubly Linked List - list of nodes, with each node pointing to the previous and next nodes\n *\n * Methods and properties:\n *\n * - insertAtBeginning: Constant — O(1)\n * - insertAtEnd: Constant — O(1)\n * - insertAt: Linear — O(n)\n * - getAt: Linear — O(n)\n * - deleteFirstNode: Constant — O(1)\n * - deleteLastNode: Constant — O(1)\n * - deleteAt: Linear — O(n)\n * - reverse: Linear — O(n)\n * - traverse: Linear — O(n)\n * - traverseReverse: Linear — O(n)\n * - isEmpty: Constant — O(1)\n * - size: Constant — O(1)\n * - enumerate: Linear - O(n)\n * - clear: Constant - O(1)\n */\n\nimport { Node } from './node'\n\nexport class DoublyLinkedList {\n  constructor() {\n    this.head = null\n    this.tail = null\n    this.length = 0\n  }\n\n  insertAtBeginning(val) {\n    const newNode = new Node(val)\n\n    // the list is currently empty\n    if (!this.head) {\n      this.head = newNode\n      this.tail = newNode\n      this.length++\n      return this.head\n    }\n\n    // the list has at least one node in it already\n    this.head.prev = newNode\n    newNode.next = this.head\n    this.head = newNode\n    this.length++\n    return this.head\n  }\n\n  insertAtEnd(val) {\n    const newNode = new Node(val)\n\n    // the list is currently empty\n    if (!this.head) {\n      return this.insertAtBeginning(val)\n    }\n\n    // the list has at least one node in it already\n    newNode.prev = this.tail\n    this.tail.next = newNode\n    this.tail = newNode\n    this.length++\n    return this.head\n  }\n\n  insertAt(val, index) {\n    // if the list is empty\n    // i.e. head = null\n    if (!this.head) {\n      return this.insertAtBeginning(val)\n    }\n\n    // if new node needs to be inserted at the front of the list\n    // i.e. before the head\n    if (index === 0) {\n      return this.insertAtBeginning(val)\n    }\n\n    // if new node needs to be inserted at the end of the list\n    // i.e. after the tail\n    if (index >= this.length) {\n      return this.insertAtEnd(val)\n    }\n\n    // else, use getAt() to find the node that is right before the specified index\n    const previous = this.getAt(index - 1)\n    let newNode = new Node(val)\n    newNode.next = previous.next\n    newNode.prev = previous\n    previous.next = newNode\n    this.length++\n    return this.head\n  }\n\n  getAt(index) {\n    let counter = 0\n    let node = this.head\n    while (node) {\n      if (counter === index) {\n        return node\n      }\n      counter++\n      node = node.next\n    }\n    return null\n  }\n\n  deleteFirstNode() {\n    // empty list, so nothing to delete\n    if (!this.head) {\n      return this.head\n    }\n\n    // if there is only one node in the list\n    if (!this.head.next) {\n      this.head = null\n      this.tail = null\n      this.length--\n      return this.head\n    }\n\n    // delete the head node and make the next node the new head\n    this.head = this.head.next\n    this.head.prev = null\n    this.length--\n    return this.head\n  }\n\n  deleteLastNode() {\n    // empty list, so nothing to delete\n    if (!this.head) {\n      return this.head\n    }\n\n    // if there is only one node in the list\n    if (!this.head.next) {\n      this.head = null\n      this.tail = null\n      this.length--\n      return this.head\n    }\n\n    // if there are multiple nodes in the list\n    this.tail = this.tail.prev\n    this.tail.next = null\n    this.length--\n    return this.head\n  }\n\n  deleteAt(index) {\n    // empty list, so nothing to delete\n    if (!this.head) {\n      return this.head\n    }\n\n    // node needs to be deleted from the front of the list\n    // i.e. delete the head.\n    if (index === 0) {\n      return this.deleteFirstNode()\n    }\n\n    // node needs to be deleted from the end of the list\n    // i.e. delete the tail.\n    if (index === this.length - 1) {\n      return this.deleteLastNode()\n    }\n\n    // else, use getAt() to find the node that is right before the specified index\n    const previous = this.getAt(index - 1)\n\n    // if the specified index does not map to a node, do nothing\n    if (!previous || !previous.next) {\n      return this.head\n    }\n\n    // if the specified index does map to a node,\n    // set the previous node's next value to the next next value,\n    // thereby removing the node you want to delete from the list\n    previous.next = previous.next.next\n    previous.next.prev = previous\n    this.length--\n    return this.head\n  }\n\n  reverse() {\n    let currentNode = this.head\n    let previousNode = null\n\n    while (currentNode !== null) {\n      // save the next pointer before we overwrite currentNode.next!\n      const tmp = currentNode.next\n\n      // switch the values of the next and prev pointers\n      currentNode.next = previousNode\n      currentNode.prev = tmp\n\n      // step forward in the list\n      previousNode = currentNode\n      currentNode = tmp\n    }\n\n    // set the new head and tail nodes when the reversal is finished\n    this.tail = this.head\n    this.head = previousNode\n  }\n\n  traverse(callback) {\n    if (typeof callback !== 'function') {\n      return false\n    }\n\n    let currentNode = this.head\n    while (currentNode !== null) {\n      callback(currentNode)\n      currentNode = currentNode.next\n    }\n\n    return true\n  }\n\n  traverseReverse(callback) {\n    if (typeof callback !== 'function') {\n      return false\n    }\n\n    let currentNode = this.tail\n    while (currentNode !== null) {\n      callback(currentNode)\n      currentNode = currentNode.prev\n    }\n\n    return true\n  }\n\n  isEmpty() {\n    return this.length === 0\n  }\n\n  size() {\n    return this.length\n  }\n\n  enumerate() {\n    const nodes = []\n    let node = this.head\n    while (node) {\n      nodes.push(node.val)\n      node = node.next\n    }\n    return nodes\n  }\n\n  clear() {\n    this.head = null\n    this.tail = null\n    this.length = 0\n    return this.head\n  }\n}\n","/**\n * Node - Contains a value and a pointer to the next node\n *\n * Meant to be used with a singly linked list\n *\n * Methods and properties:\n *\n * - val: any value\n * - next: pointer to the next node (or null)\n */\n\nexport class Node {\n  constructor(val, next = null) {\n    this.val = val\n    this.next = next\n  }\n}\n","/**\n * Linked List - list of nodes, with each node pointing to the next\n *\n * Methods and properties:\n *\n * - insertAtBeginning: Constant — O(1)\n * - insertAtEnd: Linear — O(n)\n * - insertAt: Linear — O(n)\n * - getAt: Linear — O(n)\n * - deleteFirstNode: Constant — O(1)\n * - deleteLastNode: Linear — O(n)\n * - deleteAt: Linear — O(n)\n * - reverse: Linear — O(n)\n * - traverse: Linear — O(n)\n * - isEmpty: Constant — O(1)\n * - size: Constant — O(1)\n * - enumerate: Linear - O(n)\n * - clear: Constant - O(1)\n */\n\nimport { Node } from './node'\n\nexport class LinkedList {\n  constructor() {\n    this.head = null\n    this.length = 0\n  }\n\n  insertAtBeginning(val) {\n    const newNode = new Node(val)\n    newNode.next = this.head\n    this.head = newNode\n    this.length++\n    return this.head\n  }\n\n  insertAtEnd(val) {\n    const newNode = new Node(val)\n\n    // If this is the first node added, it is the head\n    if (!this.head) {\n      this.head = newNode\n      this.length++\n      return this.head\n    }\n\n    // If there are nodes in this linked list,\n    // iterate thru the nodes and then add this\n    // new node to the end of the list so it becomes the tail\n    let currentNode = this.head\n    while (currentNode.next !== null) {\n      currentNode = currentNode.next\n    }\n    currentNode.next = newNode\n    this.length++\n    return this.head\n  }\n\n  insertAt(val, index) {\n    // if the list is empty\n    // i.e. head = null\n    if (!this.head) {\n      return this.insertAtBeginning(val)\n    }\n\n    // if new node needs to be inserted at the front of the list\n    // i.e. before the head\n    if (index === 0) {\n      return this.insertAtBeginning(val)\n    }\n\n    // if new node needs to be inserted at the end of the list\n    // i.e. after the tail\n    if (index >= this.length) {\n      return this.insertAtEnd(val)\n    }\n\n    // else, use getAt() to find the node that is right before the specified index\n    const previous = this.getAt(index - 1)\n    let newNode = new Node(val)\n    newNode.next = previous.next\n    previous.next = newNode\n    this.length++\n    return this.head\n  }\n\n  getAt(index) {\n    let counter = 0\n    let node = this.head\n    while (node) {\n      if (counter === index) {\n        return node\n      }\n      counter++\n      node = node.next\n    }\n    return null\n  }\n\n  deleteFirstNode() {\n    // empty list, so nothing to delete\n    if (!this.head) {\n      return this.head\n    }\n\n    // delete the head node and make the next node the new head\n    this.head = this.head.next\n    this.length--\n    return this.head\n  }\n\n  deleteLastNode() {\n    // empty list, so nothing to delete\n    if (!this.head) {\n      return this.head\n    }\n\n    // if there is only one node in the list\n    if (!this.head.next) {\n      this.head = null\n      this.length--\n      return this.head\n    }\n\n    // if there are multiple nodes in the list\n    let previous = this.head\n    let tail = this.head.next\n\n    while (tail.next !== null) {\n      previous = tail\n      tail = tail.next\n    }\n\n    previous.next = null\n    this.length--\n    return this.head\n  }\n\n  deleteAt(index) {\n    // empty list, so nothing to delete\n    if (!this.head) {\n      return this.head\n    }\n\n    // node needs to be deleted from the front of the list\n    // i.e. before the head.\n    if (index === 0) {\n      return this.deleteFirstNode()\n    }\n\n    // else, use getAt() to find the node that is right before the specified index\n    const previous = this.getAt(index - 1)\n\n    // if the specified index does not map to a node, do nothing\n    if (!previous || !previous.next) {\n      return this.head\n    }\n\n    // if the specified index does map to a node,\n    // set the previous node's next value to the next next value,\n    // thereby removing the node you want to delete from the list\n    previous.next = previous.next.next\n    this.length--\n    return this.head\n  }\n\n  reverse() {\n    let currentNode = this.head\n    let previousNode = null\n\n    while (currentNode !== null) {\n      // save the next pointer before we overwrite currentNode.next!\n      const tmp = currentNode.next\n\n      // reverse the next pointer to point at the previous node\n      currentNode.next = previousNode\n\n      // step forward in the list\n      previousNode = currentNode\n      currentNode = tmp\n    }\n\n    // set the new head node when the reversal is finished\n    this.head = previousNode\n\n    return true\n  }\n\n  traverse(callback) {\n    if (typeof callback !== 'function') {\n      return false\n    }\n\n    let currentNode = this.head\n    while (currentNode !== null) {\n      callback(currentNode)\n      currentNode = currentNode.next\n    }\n\n    return true\n  }\n\n  isEmpty() {\n    return this.length === 0\n  }\n\n  size() {\n    return this.length\n  }\n\n  enumerate() {\n    const nodes = []\n    let node = this.head\n    while (node) {\n      nodes.push(node.val)\n      node = node.next\n    }\n    return nodes\n  }\n\n  clear() {\n    this.head = null\n    this.length = 0\n    return this.head\n  }\n}\n","/**\n * Priority Queue - highest priority get dequeued first, like a list of calls to 911 dispatchers\n *\n * NOTE: For this implementation, we'll assume a lower number means a higher priority.\n * i.e. An item with priority 1 would be dequeued before an item with priority 3\n *\n * Methods and properties:\n *\n * - enqueue: Constant — O(1)\n * - dequeue: Constant — O(1)\n * - peek: Constant — O(1)\n * - isEmpty: Constant — O(1)\n * - size: Constant — O(1)\n * - enumerate: Linear - O(n)\n * - clear: Constant - O(1)\n */\n\nexport class PriorityQueue {\n  constructor() {\n    this.items = []\n    this.length = 0\n  }\n\n  enqueue(value, priority = 0) {\n    // handle inserting the new item in the right place according to priority\n    for (let i = 0; i < this.length; i++) {\n      if (priority < this.items[i].priority) {\n        const item = { value, priority }\n        this.items.splice(i, 0, item)\n        this.length++\n        return item\n      }\n    }\n\n    // if we've iterated through the entire priority queue,\n    // then just add the new value at the end\n    const item = { value, priority }\n    this.items.push(item)\n    this.length++\n    return item\n  }\n\n  dequeue() {\n    if (this.length) {\n      this.length--\n      return this.items.shift()\n    } else {\n      return null\n    }\n  }\n\n  peek() {\n    return this.items[0] || null\n  }\n\n  isEmpty() {\n    return this.length === 0\n  }\n\n  size() {\n    return this.length\n  }\n\n  enumerate() {\n    return this.items\n  }\n\n  clear() {\n    this.length = 0\n    this.items = []\n    return this.items\n  }\n}\n","/**\n * Queue - FIFO, like a checkout line at a grocery store\n *\n * NOTE: This queue is implemented with an array as its underlying data structure.\n *\n * Methods and properties:\n *\n * - enqueue: Constant — O(1)\n * - dequeue: Constant — O(1)\n * - peek: Constant — O(1)\n * - isEmpty: Constant — O(1)\n * - size: Constant — O(1)\n * - enumerate: Linear - O(n)\n * - clear: Constant - O(1)\n */\n\nexport class Queue {\n  constructor() {\n    this.items = []\n    this.length = 0\n  }\n\n  enqueue(val) {\n    this.items.push(val)\n    this.length++\n    return val\n  }\n\n  dequeue() {\n    if (this.length) {\n      this.length--\n      return this.items.shift()\n    } else {\n      return null\n    }\n  }\n\n  peek() {\n    return this.items[0] || null\n  }\n\n  isEmpty() {\n    return this.length === 0\n  }\n\n  size() {\n    return this.length\n  }\n\n  enumerate() {\n    return this.items\n  }\n\n  clear() {\n    this.length = 0\n    this.items = []\n    return this.items\n  }\n}\n","/**\n * Queue - FIFO, like a checkout line at a grocery store\n *\n * NOTE: This queue is implemented with a DoublyLinkedList as its underlying data structure.\n *\n * Methods and properties:\n *\n * - enqueue: Constant — O(1)\n * - dequeue: Constant — O(1)\n * - peek: Constant — O(1)\n * - isEmpty: Constant — O(1)\n * - size: Constant — O(1)\n * - enumerate: Linear - O(n)\n * - clear: Constant - O(1)\n */\n\nimport { DoublyLinkedList } from '../../doubly-linked-list/src/doubly-linked-list'\n\nexport class QueueFromDoublyLinkedList {\n  constructor() {\n    this.queue = new DoublyLinkedList()\n  }\n\n  enqueue(val) {\n    this.queue.insertAtEnd(val)\n    return val\n  }\n\n  dequeue() {\n    const dequeuedNode = this.queue.getAt(0)\n    this.queue.deleteFirstNode()\n    return dequeuedNode ? dequeuedNode.val : null\n  }\n\n  peek() {\n    const peekedNode = this.queue.getAt(0)\n    return peekedNode ? peekedNode.val : null\n  }\n\n  isEmpty() {\n    return this.queue.isEmpty()\n  }\n\n  size() {\n    return this.queue.size()\n  }\n\n  enumerate() {\n    return this.queue.enumerate()\n  }\n\n  clear() {\n    this.queue.clear()\n    // for consistency with the Queue that uses an array as its underlying data structure\n    return []\n  }\n}\n","/**\n * Stack - LIFO, like a stack of dishes\n *\n * NOTE: This stack is implemented with an array as its underlying data structure.\n *\n * Methods and properties:\n *\n * - push: Constant — O(1)\n * - pop: Constant — O(1)\n * - peek: Constant — O(1)\n * - isEmpty: Constant — O(1)\n * - size: Constant — O(1)\n * - enumerate: Linear - O(n)\n * - clear: Constant - O(1)\n */\n\nexport class Stack {\n  constructor() {\n    this.items = []\n    this.length = 0\n  }\n\n  push(val) {\n    this.items.unshift(val)\n    this.length++\n    return val\n  }\n\n  pop() {\n    if (this.length) {\n      this.length--\n      return this.items.shift()\n    } else {\n      return null\n    }\n  }\n\n  peek() {\n    return this.items[0] || null\n  }\n\n  isEmpty() {\n    return this.length === 0\n  }\n\n  size() {\n    return this.length\n  }\n\n  enumerate() {\n    return this.items\n  }\n\n  clear() {\n    this.length = 0\n    this.items = []\n    return this.items\n  }\n}\n","/**\n * Stack - LIFO, like a stack of dishes\n *\n * NOTE: This stack is implemented with a LinkedList as its underlying data structure.\n *\n * Methods and properties:\n *\n * - push: Constant — O(1)\n * - pop: Constant — O(1)\n * - peek: Constant — O(1)\n * - isEmpty: Constant — O(1)\n * - size: Constant — O(1)\n * - enumerate: Linear - O(n)\n * - clear: Constant - O(1)\n */\n\nimport { LinkedList } from '../../linked-list/src/linked-list'\n\nexport class StackFromLinkedList {\n  constructor() {\n    this.stack = new LinkedList()\n  }\n\n  push(val) {\n    this.stack.insertAtBeginning(val)\n    return val\n  }\n\n  pop() {\n    const poppedNode = this.stack.getAt(0)\n    this.stack.deleteFirstNode()\n    return poppedNode ? poppedNode.val : null\n  }\n\n  peek() {\n    const peekedNode = this.stack.getAt(0)\n    return peekedNode ? peekedNode.val : null\n  }\n\n  isEmpty() {\n    return this.stack.isEmpty()\n  }\n\n  size() {\n    return this.stack.size()\n  }\n\n  enumerate() {\n    return this.stack.enumerate()\n  }\n\n  clear() {\n    this.stack.clear()\n    // for consistency with the Stack that uses an array as its underlying data structure\n    return []\n  }\n}\n"],"names":["binarySearch","haystack","needle","showLogs","Array","searchableHaystack","i","fullHaystackMidpointIndex","length","midpointIndex","Math","floor","console","log","join","slice","linearSearch","boyerMooreHorspoolSearch","needleLength","haystackRemainingLength","jumpAmount","lastIndexOfNeedle","mismatchTable","haystackOffset","currentIndex","naiveSearch","j","Set","items","val","this","indexOf","push","index","splice","intersection","set1","set2","intersectionSet","enumerate","forEach","has","add","setDifference","setDifferenceSet","union","unionSet","symmetricDifference","bubbleSort","arr","sortedArr","didSwapSomething","iteration","firstPosition","countingSort","minValue","maxValue","countArr","min","max","currentElement","countRange","insertionSort","valueToInsert","didInsertValue","mergeSort","leftSubArray","rightSubArray","merge","arr1","arr2","result","shift","finalResult","concat","quickSort","left","right","pivotIndex","partition","swap","leftIndex","rightIndex","temp","pivotElement","currentLeftIndex","currentRightIndex","selectionSort","minValueIndex","originalStartingValue","Node","BinarySearchTree","root","newNode","_insertNode","currentNode","doesTreeContainValue","findValueInTree","_removeNode","key","_findMinNode","node","callback","inOrderTraversal","preOrderTraversal","postOrderTraversal","next","prev","DoublyLinkedList","head","tail","insertAtBeginning","insertAtEnd","previous","getAt","counter","deleteFirstNode","deleteLastNode","previousNode","tmp","nodes","LinkedList","PriorityQueue","value","priority","item","Queue","QueueFromDoublyLinkedList","queue","dequeuedNode","peekedNode","isEmpty","size","clear","Stack","unshift","StackFromLinkedList","stack","poppedNode"],"mappings":"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"}